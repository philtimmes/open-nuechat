/**
 * YouTube video info and caption extraction utilities
 * Runs in the user's browser to fetch video metadata and captions
 */

export interface YouTubeVideoInfo {
  videoId: string;
  title?: string;
  channel?: string;
  description?: string;
  transcript?: string;
  transcriptLanguage?: string;
  isAutoGenerated?: boolean;
  error?: string;
}

// YouTube URL patterns
const YOUTUBE_PATTERNS = [
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]+)/,
  /(?:https?:\/\/)?youtu\.be\/([a-zA-Z0-9_-]+)/,
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]+)/,
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]+)/,
];

/**
 * Extract video ID from a YouTube URL
 */
export function extractVideoId(url: string): string | null {
  for (const pattern of YOUTUBE_PATTERNS) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }
  return null;
}

/**
 * Check if a string contains a YouTube URL
 */
export function containsYouTubeUrl(text: string): boolean {
  return YOUTUBE_PATTERNS.some(pattern => pattern.test(text));
}

/**
 * Extract all YouTube video IDs from text
 */
export function extractAllVideoIds(text: string): string[] {
  const ids: string[] = [];
  const seen = new Set<string>();
  
  for (const pattern of YOUTUBE_PATTERNS) {
    const globalPattern = new RegExp(pattern.source, 'g');
    let match;
    while ((match = globalPattern.exec(text)) !== null) {
      if (!seen.has(match[1])) {
        seen.add(match[1]);
        ids.push(match[1]);
      }
    }
  }
  
  return ids;
}

/**
 * Fetch YouTube video info and captions using the browser
 * This works because the user's browser can access YouTube directly
 */
export async function fetchYouTubeVideoInfo(videoId: string): Promise<YouTubeVideoInfo> {
  const result: YouTubeVideoInfo = { videoId };
  
  try {
    // Fetch the video page
    const response = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
      credentials: 'omit', // Don't send cookies
      headers: {
        'Accept': 'text/html',
        'Accept-Language': 'en-US,en;q=0.9',
      },
    });
    
    if (!response.ok) {
      result.error = `Failed to fetch video page: ${response.status}`;
      return result;
    }
    
    const html = await response.text();
    
    // Extract title
    const titleMatch = html.match(/<title>([^<]+)<\/title>/);
    if (titleMatch) {
      result.title = titleMatch[1].replace(/\s*-\s*YouTube$/, '');
    }
    
    // Extract channel name
    const channelMatch = html.match(/"ownerChannelName":"([^"]+)"/);
    if (channelMatch) {
      result.channel = channelMatch[1];
    }
    
    // Extract description (short)
    const descMatch = html.match(/"shortDescription":"([^"]{0,500})/);
    if (descMatch) {
      result.description = descMatch[1]
        .replace(/\\n/g, ' ')
        .replace(/\\"/g, '"')
        .substring(0, 500);
    }
    
    // Try to extract captions
    // Look for the baseUrl in captionTracks
    const baseUrlMatch = html.match(/"baseUrl"\s*:\s*"(https:\/\/www\.youtube\.com\/api\/timedtext[^"]+)"/);
    
    if (baseUrlMatch) {
      const captionUrl = baseUrlMatch[1]
        .replace(/\\u0026/g, '&')
        .replace(/\\\//g, '/');
      
      console.log('[YouTube] Found caption URL, fetching...');
      
      try {
        const captionResponse = await fetch(captionUrl);
        if (captionResponse.ok) {
          const captionData = await captionResponse.text();
          
          // Parse the caption data (could be XML or JSON)
          if (captionData.trim().startsWith('<')) {
            // XML format: <text start="0" dur="2.5">Caption text</text>
            const textMatches = captionData.matchAll(/<text[^>]*>([^<]*)<\/text>/g);
            const lines: string[] = [];
            for (const match of textMatches) {
              const text = decodeHTMLEntities(match[1]).trim();
              if (text) {
                lines.push(text);
              }
            }
            if (lines.length > 0) {
              result.transcript = lines.join(' ');
              result.isAutoGenerated = captionUrl.includes('kind=asr');
              console.log(`[YouTube] Extracted ${lines.length} caption lines`);
            }
          } else {
            // Try JSON format
            try {
              const jsonData = JSON.parse(captionData);
              const events = jsonData.events || [];
              const lines: string[] = [];
              for (const event of events) {
                const segs = event.segs || [];
                for (const seg of segs) {
                  const text = (seg.utf8 || '').trim();
                  if (text && text !== '\n') {
                    lines.push(text);
                  }
                }
              }
              if (lines.length > 0) {
                result.transcript = lines.join(' ');
                result.isAutoGenerated = true;
                console.log(`[YouTube] Extracted ${lines.length} caption segments from JSON`);
              }
            } catch {
              // Not JSON either
            }
          }
        }
      } catch (captionError) {
        console.warn('[YouTube] Failed to fetch captions:', captionError);
      }
    }
    
    // If no baseUrl found, try to find captionTracks and extract from there
    if (!result.transcript) {
      const captionTracksMatch = html.match(/"captionTracks"\s*:\s*(\[[^\]]+\])/);
      if (captionTracksMatch) {
        try {
          const tracks = JSON.parse(captionTracksMatch[1]);
          console.log(`[YouTube] Found ${tracks.length} caption tracks`);
          
          // Find English track or first available
          let targetTrack = tracks.find((t: { languageCode: string }) => 
            t.languageCode?.startsWith('en')
          ) || tracks[0];
          
          if (targetTrack?.baseUrl) {
            const captionUrl = targetTrack.baseUrl
              .replace(/\\u0026/g, '&')
              .replace(/\\\//g, '/');
            
            const captionResponse = await fetch(captionUrl);
            if (captionResponse.ok) {
              const captionData = await captionResponse.text();
              const textMatches = captionData.matchAll(/<text[^>]*>([^<]*)<\/text>/g);
              const lines: string[] = [];
              for (const match of textMatches) {
                const text = decodeHTMLEntities(match[1]).trim();
                if (text) {
                  lines.push(text);
                }
              }
              if (lines.length > 0) {
                result.transcript = lines.join(' ');
                result.transcriptLanguage = targetTrack.languageCode;
                result.isAutoGenerated = targetTrack.kind === 'asr' || 
                  (targetTrack.vssId || '').toLowerCase().includes('asr');
                console.log(`[YouTube] Extracted ${lines.length} caption lines from track`);
              }
            }
          }
        } catch (e) {
          console.warn('[YouTube] Failed to parse caption tracks:', e);
        }
      }
    }
    
    if (!result.transcript && !result.title) {
      result.error = 'Could not extract video information';
    }
    
  } catch (error) {
    console.error('[YouTube] Error fetching video info:', error);
    result.error = error instanceof Error ? error.message : 'Unknown error';
  }
  
  return result;
}

/**
 * Decode HTML entities in caption text
 */
function decodeHTMLEntities(text: string): string {
  const textarea = document.createElement('textarea');
  textarea.innerHTML = text;
  return textarea.value;
}

/**
 * Format video info for sending to backend
 */
export function formatVideoContext(info: YouTubeVideoInfo): string {
  const parts: string[] = [];
  
  parts.push(`[YouTube Video: ${info.videoId}]`);
  
  if (info.title) {
    parts.push(`Title: ${info.title}`);
  }
  
  if (info.channel) {
    parts.push(`Channel: ${info.channel}`);
  }
  
  if (info.description) {
    parts.push(`Description: ${info.description}`);
  }
  
  if (info.transcript) {
    const autoNote = info.isAutoGenerated ? ' (auto-generated)' : '';
    const langNote = info.transcriptLanguage ? ` [${info.transcriptLanguage}]` : '';
    parts.push(`\nTranscript${langNote}${autoNote}:\n${info.transcript}`);
  } else if (info.error) {
    parts.push(`Note: ${info.error}`);
  }
  
  return parts.join('\n');
}
